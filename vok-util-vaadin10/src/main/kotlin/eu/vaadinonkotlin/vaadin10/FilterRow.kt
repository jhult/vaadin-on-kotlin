package eu.vaadinonkotlin.vaadin10

import eu.vaadinonkotlin.FilterFactory
import eu.vaadinonkotlin.Listeners
import eu.vaadinonkotlin.listeners
import com.vaadin.flow.component.Component
import com.vaadin.flow.component.HasSize
import com.vaadin.flow.component.HasValue
import com.vaadin.flow.component.combobox.ComboBox
import com.vaadin.flow.component.grid.Grid
import com.vaadin.flow.component.grid.HeaderRow
import com.vaadin.flow.component.textfield.TextField
import com.vaadin.flow.data.binder.BeanPropertySet
import com.vaadin.flow.data.binder.PropertyDefinition
import com.vaadin.flow.data.provider.ConfigurableFilterDataProvider
import com.vaadin.flow.data.value.HasValueChangeMode
import com.vaadin.flow.data.value.ValueChangeMode
import com.vaadin.flow.function.SerializableConsumer
import com.vaadin.flow.shared.Registration
import java.io.Serializable
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.streams.toList

/**
 * Maintains a set of fields - monitors bound fields for values and provides [filter] of type F.
 * Fires [onFilterChangeListeners] on every filter change.
 *
 * Use [FilterRow] to add filters to Grid easily.
 * @param T the type of items in the grid.
 * @param F the type of the filter
 * @param filterFieldFactory used to create filters from filter components by invoking [FilterFieldFactory.createFilter]
 */
class FilterBinder<T : Any, F : Any>(val filterFieldFactory: FilterFieldFactory<T, F>,
                                     val filterFactory: FilterFactory<F>) : Serializable {

    /**
     * The current filter as generated by [filterFieldFactory] from the most current states of all bound filter fields.
     * Updated on every filter field change.
     */
    var filter: F? = null
        private set

    /**
     * Invoked when the [filter] changes.
     */
    val onFilterChangeListeners: Listeners<SerializableConsumer<F?>> = listeners()

    private val filterComponents: MutableMap<HasValue<*, *>, FilterFieldWatcher<*, *>> = mutableMapOf()

    /**
     * Binds given filtering field to a container - starts filtering based on the contents of the field, and starts watching for field value changes.
     * Does not add the component to the [headerRow].
     * @param field The field which provides the filtering values, not null. [FilterFieldFactory.createFilter] is used to convert
     * the field's value to a filter.
     * @param property The bean property on which the filtering will be performed, not null.
     */
    fun <E : HasValue.ValueChangeEvent<V?>, V> bind(field: HasValue<E, V?>, property: PropertyDefinition<T, V?>) {
        unbind(field)
        val filterFieldWatcher = FilterFieldWatcher(field, property)
        filterFieldWatcher.registration = field.addValueChangeListener(filterFieldWatcher)
        filterComponents[field] = filterFieldWatcher
    }

    fun unbind(field: HasValue<*, *>) {
        filterComponents.remove(field)?.unregisterWatcher()
    }

    fun unbindAll() {
        filterComponents.keys.toList().forEach { unbind(it) }
    }

    /**
     * Listens on value change on given field and updates [ConfigurableFilterDataProvider.setFilter] accordingly.
     * @property field The field which provides the filtering values.
     * @property property The bean property on which the filtering will be performed.
     * @param V the value type
     */
    private inner class FilterFieldWatcher<E : HasValue.ValueChangeEvent<V?>, V>(private val field: HasValue<E, V?>, private val property: PropertyDefinition<T, V?>) :
            HasValue.ValueChangeListener<E> {

        /**
         * The current container filter, may be null if no filtering is currently needed because the
         * field's value indicates that the filtering is disabled for this column (e.g. the text filter is blank, the filter field is cleared, etc).
         */
        var currentFilter: F? = null

        init {
            valueChange()
        }

        override fun valueChanged(event: E) {
            valueChange()
        }

        private fun valueChange(value: V? = field.value) {
            val newFilter = filterFieldFactory.createFilter(value, field, property)
            setNewFilter(newFilter)
        }

        private fun setNewFilter(newFilter: F?) {
            if (newFilter != currentFilter) {
                currentFilter = newFilter
                recomputeFilter()
            }
        }

        fun unregisterWatcher() {
            setNewFilter(null)
            registration.remove()
        }

        lateinit var registration: Registration
    }

    private fun recomputeFilter() {
        val filters: Set<F> = filterComponents.values.mapNotNull { it.currentFilter }.toSet()
        filter = filterFactory.and(filters)
        onFilterChangeListeners.fire.accept(filter)
    }
}

/**
 * Wraps [HeaderRow] and uses [FilterBinder] to track filter UI components for changes. After the user
 * changes the value in the filter UI component, a new Grid filter of type [F] is computed and
 * set to [Grid.getDataProvider].
 *
 * Every field is configured in the [configureField] function - override and modify
 * to change the config defaults.
 * @param T the type of items in the grid.
 * @param F the type of the filters accepted by grid's [ConfigurableFilterDataProvider].
 * @param grid the owner grid. It is expected that [Grid.getDataProvider] is of type [VokDataProvider]<T>
 * (or [ConfigurableFilterDataProvider]<T, F, F>).
 * @property itemClass the type of items shown by the Grid.
 * @property headerRow the wrapped header row
 * @property filterFieldFactory used to automatically create filter UI components
 * for bean properties, and to create Grid filters of type [F].
 * @param filterFactory used to combine filter values when multiple filters are applied
 * (using the [FilterFactory.and] function).
 * @property componentConfigurator invoked for every filter component when created. By default every component
 * is set to 100% and [TextField.isClearButtonVisible]/[ComboBox.isClearButtonVisible] is set to true, and by default this closure
 * will do nothing.
 */
@Suppress("UNCHECKED_CAST")
class FilterRow<T : Any, F : Any>(
        val grid: Grid<T>, val itemClass: Class<T>,
        val headerRow: HeaderRow,
        val filterFieldFactory: FilterFieldFactory<T, F>,
        filterFactory: FilterFactory<F>,
        private val componentConfigurator: (filterComponent: HasValue<*, *>, property: PropertyDefinition<T, *>) -> Unit = { _, _ -> }
) : Serializable {

    private val binder: FilterBinder<T, F> = FilterBinder(filterFieldFactory, filterFactory)

    init {
        binder.onFilterChangeListeners.add(SerializableConsumer { filter: F? ->
            (grid.dataProvider as ConfigurableFilterDataProvider<T, F, F>).setFilter(filter)
        })
    }

    /**
     * Map mapping [T] property name to the filtering component generated.
     */
    private val filterComponents: MutableMap<String, Component> = mutableMapOf()

    /**
     * Invoked when the filter changes.
     */
    val onFilterChangeListeners: Listeners<SerializableConsumer<F?>>
        get() = binder.onFilterChangeListeners

    /**
     * Re-generates all filter components in this header row. Removes all old filter components and
     * creates a new set and populates them into the [headerRow].
     */
    fun generateFilterComponents(valueChangeMode: ValueChangeMode = ValueChangeMode.EAGER) {
        binder.unbindAll()
        filterComponents.clear()

        val properties: Map<String, PropertyDefinition<T, *>> =
                BeanPropertySet.get(itemClass).properties.toList().associateBy { it.name }
        for (propertyId in grid.columns.mapNotNull { it.key }) {
            val property: PropertyDefinition<T, *>? = properties[propertyId]
            val field: HasValue<*, *>? = if (property == null) null else filterFieldFactory.createField(property)
            if (field != null) {
                (field as? HasValueChangeMode)?.valueChangeMode = valueChangeMode
                binder.bind(field as HasValue<HasValue.ValueChangeEvent<Any?>, Any?>, property!! as PropertyDefinition<T, Any?>)
                filterComponents[propertyId] = field as Component
                configureField(field, property)
            }
            headerRow.getCell(grid.getColumnByKey(propertyId)).setComponent(field as Component?)
        }
    }

    /**
     * Configures every Vaadin UI filter [field]. By default the width is set to 100%
     * and the clear button is made visible for [TextField] and [ComboBox].
     *
     * Override to change the configuration defaults.
     */
    private fun configureField(field: HasValue<*, *>, property: PropertyDefinition<T, *>) {
        (field as? HasSize)?.width = "100%"
        (field as? TextField)?.isClearButtonVisible = true
        (field as? ComboBox)?.isClearButtonVisible = true
        componentConfigurator(field, property)
    }

    /**
     * @return map mapping [T] property name to the filtering component generated.
     */
    fun getFilterComponents(): Map<String, Component> = filterComponents

    /**
     * Unbinds all filters and clears the [headerRow] (sets null component to every cell).
     */
    fun clear() {
        binder.unbindAll()
        grid.columns.forEach { column -> headerRow.getCell(column).setComponent(null) }
        filterComponents.clear()
    }

    /**
     * Returns the filter component filtering given [property]. Fails if no filter component has been generated for
     * that property.
     */
    fun getFilterComponent(property: KProperty1<T, *>): HasValue<HasValue.ValueChangeEvent<Any?>, Any?> {
        val component = filterComponents[property.name]
                ?: throw IllegalArgumentException("There is no filter configured for $property")
        return component as HasValue<HasValue.ValueChangeEvent<Any?>, Any?>
    }
}


/**
 * Re-creates filters in this header row. Simply call `grid.appendHeaderRow().generateFilterComponents(grid)` to automatically attach
 * filters to non-generated columns. Please note that filters are not re-generated when the container data source is changed.
 *
 * Note that this function expects that you're using your own custom filter hierarchy. That is rarely the case since most often
 * you use filters from `vok-dataloader`. In such case please use [generateFilterComponents].
 * @param T the type of items in the grid.
 * @param grid the owner grid.
 * @param filterFactory
 * @param filterFieldFactory used to create the filters themselves. If null, [DefaultFilterFieldFactory] is used.
 * @param valueChangeMode how eagerly to apply the filtering after the user changes the filter value. Only applied to [HasValueChangeMode];
 * typically only applies to inline filter
 * components (most importantly [com.vaadin.flow.component.textfield.TextField]), typically ignored for popup components (such as [com.github.vok.framework.NumberFilterPopup])
 * where the values are applied after the user clicks the "Apply" button. Defaults to [ValueChangeMode.EAGER].
 * @param componentConfigurator invoked for every filter component when created. By default every component
 * is set to 100% and [TextField.isClearButtonVisible]/[ComboBox.isClearButtonVisible] is set to true, and by default this closure
 * will do nothing.
 */
@Suppress("UNCHECKED_CAST")
fun <T : Any, F : Any> HeaderRow.generateFilterComponents2(
        grid: Grid<T>, itemClass: KClass<T>,
        filterFactory: FilterFactory<F>,
        filterFieldFactory: FilterFieldFactory<T, F> = DefaultFilterFieldFactory(itemClass.java, filterFactory),
        valueChangeMode: ValueChangeMode = ValueChangeMode.EAGER,
        componentConfigurator: (filterComponent: HasValue<*, *>, property: PropertyDefinition<T, *>) -> Unit = { _, _ -> }
): FilterRow<T, F> {
    val filterRow: FilterRow<T, F> = FilterRow(grid, itemClass.java, this,
            filterFieldFactory, filterFactory, componentConfigurator)
    filterRow.generateFilterComponents(valueChangeMode)
    return filterRow
}
